/*******************************************************************************
 * Copyright (c) 2007, 2012 John Bradley
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     John Bradley - initial API and implementation
 *     John Bradley - substantial change to focus all Pliny's RDB(Derby) interaction here
 *******************************************************************************/

package uk.ac.kcl.cch.jb.pliny.data.rdb;

import java.sql.*;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;

import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Plugin;

import uk.ac.kcl.cch.jb.pliny.PlinyPlugin;
import uk.ac.kcl.cch.jb.pliny.data.IDataServerWithCaching;
import uk.ac.kcl.cch.jb.pliny.data.IFileCacheManager;
import uk.ac.kcl.cch.jb.pliny.model.GlobalData;
import uk.ac.kcl.cch.jb.pliny.model.ResourceCache;
import uk.ac.kcl.cch.jb.pliny.model.ResourceQuery;
import uk.ac.kcl.cch.rdb2java.dynData.BaseQuery;
import uk.ac.kcl.cch.rdb2java.dynData.CountItem;
import uk.ac.kcl.cch.rdb2java.dynData.IDataInserter;
import uk.ac.kcl.cch.rdb2java.dynData.IDataServer;
import uk.ac.kcl.cch.rdb2java.dynData.IObjectFetcher;
import uk.ac.kcl.cch.rdb2java.dynData.IPersistentQuery;
import uk.ac.kcl.cch.rdb2java.dynData.PropertyChangeObject;
import uk.ac.kcl.cch.rdb2java.dynData.SigninException;

/**
 *
 * provides linking services between the DB engine and the 
 * <code>rdb2java</code> model objects.  This version, which
 * supports an embedded link to the <code>Derby</code> database can also
 * set up the tables in the DB when it is first created.
 * 
 * Those familiar with earlier versions of Pliny will see this as substantially different
 * from earlier versions.  This now implements IDataServer which provides an interface which
 * localises all data interaction into this code.  By doing this Pliny can now support other
 * data storage technologies than RDB (indeed, in parallel to this work, a Google Cloud 
 * storage model has been implemented.
 *
 * @author John Bradley
 * @version 
 */
public class DBServices extends PropertyChangeObject implements IDataServerWithCaching{
  private static Connection conn;
  
  private static final String[] setupSQL = {
    "create table Plugin (pluginKey SMALLINT not null generated by default as identity, idString VARCHAR(255) not null default \'\', primary key (pluginKey))",
    "create table ObjectType (objectTypeKey INT not null generated by default as identity, name VARCHAR(100) not null default \'\', pluginKey SMALLINT not null default 0, idString VARCHAR(255) not null default \'\', editorId VARCHAR(255) not null default \'\', iconId VARCHAR(255) , primary key (objectTypeKey))",
    "create index ObjectType_pluginKey on ObjectType (pluginKey)",
    "create table Resource (resourceKey INT not null generated by default as identity, fullName VARCHAR(255) not null default \'\', initChar CHAR(1) not null default \' \', objectTypeKey INT not null default 0, identifier CLOB , idStart VARCHAR(100) not null default \'\', attributes CLOB , creationDate DATE not null default \'2007-01-01\', creationTime TIME not null default \'00:01\', primary key (resourceKey))",
    "create index Resource_objectTypeKey on Resource (objectTypeKey)",
    "create table Note (resourceKey INT not null default 0, content CLOB , tStamp TIMESTAMP , primary key (resourceKey))",
    "create index Note_resourceKey on Note (resourceKey)",
    "create table LinkableObject (linkableObjectKey INT not null generated by default as identity, typeKey SMALLINT not null default 1, position CLOB , displPageNo INT not null default 0, surrPageNo INT not null default 0, displayedInKey INT not null default 0, surrogateForKey INT not null default 0, isOpen CHAR(1) not null default \'Y\', showingMap CHAR(1) not null default \'N\', primary key (linkableObjectKey))",
    "create index LinkableObject_typeKey on LinkableObject (typeKey)",
    "create index LinkableObject_displayedInKey on LinkableObject (displayedInKey)",
    "create index LinkableObject_surrogateForKey on LinkableObject (surrogateForKey)",
    "create table Link (linkKey INT not null generated by default as identity, attributes CLOB , fromLink INT not null default 0, toLink INT not null default 0, typeKey SMALLINT not null default 0, primary key (linkKey))",
    "create index Link_fromLink on Link (fromLink)",
    "create index Link_toLink on Link (toLink)",
    "create index Link_typeKey on Link (typeKey)",
    "create table Favourite (favouriteKey INT not null generated by default as identity, favouriteResource INT not null default 0, primary key (favouriteKey))",
    "create index Favourite_favouriteResource on Favourite (favouriteResource)",
    "create table LOType (loTypeKey SMALLINT not null generated by default as identity, name VARCHAR(255) not null default \'\', titleForeColour INT not null default 0, titleBackColour INT not null default 0, bodyForeColour INT not null default 0, bodyBackColour INT not null default 0, sourceRoleKey INT not null default 0, targetRoleKey INT not null default 0, primary key (loTypeKey))",
    "create index LOType_sourceRoleKey on LOType (sourceRoleKey)",
    "create index LOType_targetRoleKey on LOType (targetRoleKey)",
    "create table GlobalData (globalDataKey SMALLINT not null generated by default as identity, typeVal SMALLINT not null default 0, numbVal INT not null default 0, strVal VARCHAR(255) not null default \'\', primary key (globalDataKey))",
    "INSERT INTO ObjectType (name, pluginKey, idString, editorId, iconId) VALUES (\'Note\',1,\'\',\'uk.ac.kcl.cch.jb.pliny.noteEditor\',NULL)",
    "INSERT INTO ObjectType (name, pluginKey, idString, editorId, iconId) VALUES (\'Web Browser\',1,\'\',\'uk.ac.kcl.cch.jb.pliny.browserEditor\',\'\')",
    "INSERT INTO Plugin (idString) VALUES (\'uk.ac.kcl.cch.jb.pliny\')",
    "create index resourceInits on Resource (objectTypeKey,initChar)",
    "insert into LOType (name, titleForeColour, titleBackColour, bodyForeColour, bodyBackColour) values (\'\', 0,65280,0,15794160)",
    "insert into LOType (name, titleForeColour, titleBackColour, bodyForeColour, bodyBackColour) values (\'source document\', 16777215,255,0,15790335)"
  };

  public static Connection getConnection(){
  	 if(conn == null) setupConnection();
  	 return conn;
  }

  public static void returnConnection(Connection c){
  }
  
  public static final int UNDEFINED = 0; 
  public static final int GENERAL = 1;
  public static final int ACCOUNT = 2;
  
  private static final String PROJECT="model";

  private static String DEFAULTDRIVER = "org.apache.derby.jdbc.EmbeddedDriver";
  private static String DEFAULTCONNSTRING = "jdbc:derby:&dbname;;create=true";
  private static String DEFAULTACCOUNT = "pliny";
  private static String DEFAULTPASSWORD = "pliny";
  private static String DEFAULTDBNAME = "pliny";
  
  private PlinyPlugin plugin = null;
  
  public static void setDBName(String dbName){
	  DEFAULTDBNAME = dbName;
  }
  
    private static void setupConnection(){
        conn = null;
        //String derbyVersion = (String) Platform.getBundle("org.apache.derby.core").getHeaders().get("Bundle-Version");
        //System.out.println(derbyVersion);

        try
        {
        	String myConnector = DEFAULTCONNSTRING.replaceAll("&dbname;",DEFAULTDBNAME);
            Class.forName (DEFAULTDRIVER).newInstance ();
            conn = DriverManager.getConnection (
            		myConnector, 
            		DEFAULTACCOUNT, DEFAULTPASSWORD);
        }
        catch (Exception e){
        	e.printStackTrace();
        	return;
        }
        boolean dbDefined = false;
        try {
        	Statement stmt = conn.createStatement();
        	ResultSet rs = stmt.executeQuery("select TABLENAME from SYS.SYSTABLES where TABLETYPE='T'");
        	while(rs.next())dbDefined = true;
        	stmt.close();
        } catch (Exception e){
        	e.printStackTrace();
        	closeConnection();
        }
        if(dbDefined  || (conn == null))return;
        try {
        	Statement stmt;
        	for(int i = 0; i < setupSQL.length; i++){
        		stmt = conn.createStatement();
        		stmt.executeUpdate(setupSQL[i]);
        		stmt.close();
        	}
		addVersion();
        } catch (Exception e){
        	e.printStackTrace();
        	closeConnection();
        }
    }
    
    private static void addVersion() throws Exception{
	String pluginVersionString = (String)PlinyPlugin.getDefault().getBundle().getHeaders().get("Bundle-Version");
        GlobalData.setupVersion(pluginVersionString);
    }
    
    /** Creates new DBServices */
    public DBServices(String dbName, PlinyPlugin plugin) {
    	DEFAULTDBNAME = dbName;
    	this.plugin = plugin;
    }
    
    public void start() throws SigninException{
    	if(conn == null)setupConnection();
    	(new DbVersionManager(plugin)).run();
    }
    
    public void dispose(){
    	closeConnection();
    }

    public static void closeConnection(){
    	try{
    	  if(conn != null)conn.close();
    	}
    	catch (Exception e){
    		e.printStackTrace();
    	}
    	conn = null;
    }
    
    public static String getNewKeyQuery(String tableName){
    	return "select IDENTITY_VAL_LOCAL() from "+tableName;

    }
    
    public void notifyCreate(String type, Object object){
    	firePropertyChange("Create-"+type, null, object);
    }
    
    public void notifyDelete(String type, Object object){
    	firePropertyChange("Delete-"+type, object, null);
    }
    
    private static Map<String, PreparedStatement> fetches = new HashMap<String, PreparedStatement>();
    
    public ResultSet fetchItem(IObjectFetcher of, int ID){
    	Object rslt = null;
    	PreparedStatement fetchStmt = fetches.get(of.getEntityName());
    	try {
    		if(fetchStmt == null){
    			String query = "select "+of.getMySelectEntities()+" from "+of.getMySQLFrom()+
    			" where "+of.getMyKeyName()+" = ?";
    			if(!of.getMyTableJoins().equals(""))
    				query += " and " + of.getMyTableJoins();
    			fetchStmt = conn.prepareStatement(query);
    			fetches.put(of.getEntityName(), fetchStmt);
    		}
    		fetchStmt.setInt(1,ID);
    		ResultSet rs = fetchStmt.executeQuery();
    		return rs;
    	} catch( Exception e) {
    		e.printStackTrace(System.out);
    	}
    	return null;
    }
    
    private String prepareString(String val){
    	String rslt = val.replaceAll("'", "\\'");
    	rslt = rslt.replaceAll("\n", "\\n");
    	return rslt;
    }
    
    private String handleConstraints(BaseQuery bq){
    	if(bq.getConstraints() == null)return null;
    	String connector = "";
    	StringBuffer buf = new StringBuffer();
    	for(BaseQuery.ConstraintValue c: bq.getConstraints()){
    		if(c.getOp().equals(BaseQuery.FilterSTARTS)){
    			String val = c.getValue();
    			if(val == null)throw new RuntimeException("Start Filter provided against nonstring value");
    			String stringLower = val.toLowerCase();
    			buf.append("LOWER("+c.getAttrName()+") like '"+stringLower+"%'");
    		}else{
        		buf.append(connector + c.getAttrName());
    			buf.append(c.getOp());
    			if(c.isParam())buf.append("?");
    			else if(c.getDValue()!= null)buf.append("'"+c.getDValue().toString()+"'");
        		else if(c.getValue() == null)buf.append(c.getIValue());
        		else buf.append("'"+prepareString(c.getValue())+"'");
    		}
    		connector = " AND ";
    	}
    	return new String(buf);
    }
    
    private String makeOrderString(BaseQuery bq){
    	Vector<BaseQuery.OrderParam> orderParams = bq.getOrderParams();
    	if(orderParams == null || orderParams.size() == 0)return null;
    	StringBuffer buf = new StringBuffer();
    	String sep = "";
    	for(BaseQuery.OrderParam param: orderParams){
    		if(param.getDirection().equals(BaseQuery.OrderASC_LOWER))
    			buf.append(sep+"LOWER("+param.getAttrName()+") asc");
    		else buf.append(sep+param.getAttrName()+" "+param.getDirection());
    		sep = ",";
    	}
    	return new String(buf);
    }

    private String makeQueryStatement(BaseQuery bq, boolean doCount){
    	String query = null;
    	if(doCount)
    		query = "select count("+bq.getMyKeyName() + ") from "+bq.getMySQLFrom();
    	else {
    		String queryinit = "select ";
    		if(bq.getDoDistinct())queryinit = "select distinct ";
    		query = queryinit+bq.getMyKeyName();
    		if(bq instanceof ResourceQuery) query = query + ",Resource.objectTypeKey";
    		query = query + " from "+bq.getMySQLFrom();
    	}

    	//if(fromString != null)query = query + ", "+fromString;

    	String connector = " WHERE ";
    	if(!bq.getMyTableJoins().equals("")){
    		query = query + connector + bq.getMyTableJoins();
    		connector = " AND ";
    	}
    	//if(cgiWhereString != null){ query = query + connector + cgiWhereString; connector = " and "; }
    	String whereString = handleConstraints(bq);
    	if(whereString != null && whereString.length() > 0) query = query + connector+whereString;
    	String orderString = makeOrderString(bq);
    	if(orderString != null) query = query + " order by "+orderString;
    	return query;
    }

    protected Statement theStatement;

    protected ResultSet runBasicQuery(String query) throws SQLException{
    	Statement stmt;
    	stmt = conn.createStatement();
    	theStatement = stmt;
    	return stmt.executeQuery(query);
    }

    protected ResultSet runParamQuery(BaseQuery bq, String query) throws SQLException{
    	PreparedStatement stmt;
    	stmt = conn.prepareStatement(query);
    	theStatement = stmt;
    	Iterator it = bq.getQueryParams().iterator();
    	int cnt  = 0;
    	while(it.hasNext())
    		stmt.setObject(++cnt, it.next());
    	//stmt.setString(++cnt, (String)it.next());
    	return stmt.executeQuery();
    }

    public Vector runQuery(BaseQuery bq){
    	boolean isResourceQuery = bq instanceof ResourceQuery; // needs special handling  .jb
    	Vector results = null;
		ResultSet rs = null;
    	try {
    		if(bq.getQueryParams() == null)rs = runBasicQuery(makeQueryStatement(bq,false));
    		else rs = runParamQuery(bq, makeQueryStatement(bq,false));
    		//htResults = new Hashtable();
    		results = new Vector();

    		while(rs.next()){
    			int currKey = rs.getInt(1);
    			Object d = null;
    			if(isResourceQuery){
    	           int typeVal = rs.getInt(2);
    	    	   d = ((ResourceCache)(bq.getMyCache())).getItem(currKey, typeVal);
    			}
    			else d = bq.getObject(currKey);
    			results.add(d);
    			//htResults.put(new Integer(currKey), d);
    		}
    		rs.close();
    		theStatement.close();
    	} catch( Exception e) {
    		e.printStackTrace(System.out);
    		return results;
    	}
    return results;
    }
    
    public int runCountQuery(BaseQuery bq){
    	int count = 0;
    	try {
		    ResultSet rs = null;
    		if(bq.getQueryParams() == null)rs = runBasicQuery(makeQueryStatement(bq,true));
    		else rs = runParamQuery(bq, makeQueryStatement(bq,true));

    		while(rs.next()){
    		   count = rs.getInt(1);
    		}
    		rs.close();
    		theStatement.close();
    	} catch( Exception e) {
    		e.printStackTrace(System.out);
    	}
    return count;
    }
    
    public ResultSet prepareFullValueResultSet(BaseQuery bq){
		String query = "select "+bq.getMySelectEntities()+" from "+bq.getMySQLFrom();
		//if(bq.getFromString() != null)query += ", "+bq.getFromString();
	     String connector = " WHERE ";
	     if(!bq.getMyTableJoins().equals("")){
	        query = query + connector + bq.getMyTableJoins();
	        connector = " AND ";
	     }
	     //if(bq.getWhereString() != null) query = query + connector+bq.getWhereString();
	     String whereString = handleConstraints(bq);
	     if(whereString != null && whereString.length() > 0) query = query + connector+whereString;
	     String orderString = makeOrderString(bq);
	     if(orderString != null) query = query + " order by "+orderString;

	     Statement stmt;
	     //Connection conh = bq.getMyConnection();
	     ResultSet rs = null;
	     try {
			stmt = conn.createStatement();
			rs = stmt.executeQuery(query);
		 } catch (SQLException e) {
				e.printStackTrace();
		 }
    	return rs;
    }
    
    public PreparedStatement makeStatement(BaseQuery bq) throws SQLException{
		return conn.prepareStatement(makeQueryStatement(bq, false));
    }
    
    public PreparedStatement makeStatement(BaseQuery bq, boolean count) throws SQLException{
    	return conn.prepareStatement(makeQueryStatement(bq, count));
    }
    
    public IPersistentQuery makePersistentQuery(BaseQuery bq, String foreignKeyName){
    	return new DBPersistentQuery(this, bq, foreignKeyName);
    }
    
    public IDataInserter makeDataInserter(String tableName){
    	return new DBDataInserter(tableName, this);
    }
    
    public boolean isNoteInSeparateEntity(){return true;}
    
    public void doDelete(String entityName, String keyName, int key){
        Statement stmt;
        try {
          stmt = conn.createStatement();
          int num = stmt.executeUpdate("delete from "+entityName+" where "+keyName+"="+key);
          stmt.close();
        } catch( Exception e) {
          e.printStackTrace(System.out);
        }    	
    }
    
    public void doFkAssignment(String table, String column, int from, int to){
        try {
            Statement stmt = conn.createStatement();
            int num = stmt.executeUpdate("Update "+table+" set "+column+" = "+to+" where "+column+"="+from);
            stmt.close();
            stmt = conn.createStatement();
            num = stmt.executeUpdate("Delete from "+table+" where "+column+"="+from);
            stmt.close();
          } catch( Exception e) {
            e.printStackTrace(System.out);
          }
    }
    
    public void doUpdate(String tableName, String attr, String keyName, int keyVal, int newValue){
	      Statement stmt1;
	      try {
	    	stmt1 = conn.createStatement();
	        stmt1.executeUpdate("UPDATE "+tableName+
	        		" SET "+attr+"="+newValue+"where "+keyName+"="+keyVal);
	        stmt1.close();
	     } catch( Exception e) {
	        e.printStackTrace(System.out);
	     } 
    }

	public void doUpdate(String tableName, String attr, String keyName, int keyVal, String newValue) {
	      PreparedStatement stmt1;
	      try {
	          stmt1 = conn.prepareStatement("UPDATE "+tableName+
		        		" SET "+attr+"=? where "+keyName+"="+keyVal);
	          stmt1.setString(1, newValue);
	          stmt1.executeUpdate();
	          stmt1.close();
	     } catch( Exception e) {
	        e.printStackTrace(System.out);
	     }
	}
	
	public void doUpdate(String tableName, String attr, String keyName, int keyVal, Timestamp newValue) {
	      PreparedStatement stmt1;
	      try {
	          stmt1 = conn.prepareStatement("UPDATE "+tableName+
		        		" SET "+attr+"=? where "+keyName+"="+keyVal);
	          stmt1.setTimestamp(1, newValue);
	          stmt1.executeUpdate();
	          stmt1.close();
	     } catch( Exception e) {
	        e.printStackTrace(System.out);
	     }
	}

	public void doUpdate(String tableName, String attr, String keyName,
			int keyVal, Date newValue) {
	      PreparedStatement stmt1;
	      try {
	          stmt1 = conn.prepareStatement("UPDATE "+tableName+
		        		" SET "+attr+"=? where "+keyName+"="+keyVal);
	          stmt1.setDate(1, newValue);
	          stmt1.executeUpdate();
	          stmt1.close();
	     } catch( Exception e) {
	        e.printStackTrace(System.out);
	     }
	}

	@Override
	public void doUpdate(String tableName, String attr, String keyName,
			int keyVal, Time newValue) {
	      PreparedStatement stmt1;
	      try {
	          stmt1 = conn.prepareStatement("UPDATE "+tableName+
		        		" SET "+attr+"=? where "+keyName+"="+keyVal);
	          stmt1.setTime(1, newValue);
	          stmt1.executeUpdate();
	          stmt1.close();
	     } catch( Exception e) {
	        e.printStackTrace(System.out);
	     }
	}
	
	private static PreparedStatement updateNameStatement = null;
	
	public void doResourceFullnameAndInitUpdate(String fullName, String init, int key){
	      try {
	    	  if(updateNameStatement == null)
	    		  updateNameStatement = conn.prepareStatement(
	        		  "UPDATE Resource SET fullName=?, initChar=? where ResourceKey=?");
		      //stmt1.setBytes(1, newValue.getBytes("ISO8859-1"));
	    	  updateNameStatement.setString(1, fullName);
	    	  updateNameStatement.setString(2,init);
	    	  updateNameStatement.setInt(3,key);
	    	  updateNameStatement.executeUpdate();
	     } catch( Exception e) {
	        e.printStackTrace(System.out);
	     }	
	}
	
	private Vector<CountItem> doCount(String sql){
		Vector<CountItem> result = new Vector<CountItem>();
		try{
			Statement stmt = conn.createStatement();
			ResultSet rs = stmt.executeQuery(sql);
			while(rs.next()){
				Object object = rs.getObject(1);
				int count = rs.getInt(2);
				result.add(new CountItem(object, count));
			}
		} catch(Exception e){
			e.printStackTrace(System.out);
		}
		return result;
		
	}
	
	public Vector<CountItem> queryCount(String itemColName, String entityName, String keyName, String order){
		String sql = "select "+itemColName+", count("+keyName+") from "+entityName+" "+
		"group by "+itemColName+" order by "+itemColName+" "+order;
		return doCount(sql);
	}
	
	public Vector<CountItem> queryCount(String itemColName, String entityName, String keyName, 
			String constraintAttr, int constraintValue, String order){
		String sql = "select "+itemColName+", count("+keyName+") from "+entityName+" "+
		"where "+constraintAttr+"="+constraintValue+" "+
		"group by "+itemColName+" order by "+itemColName+" "+order;
		return doCount(sql);
	}

	@Override
	public IFileCacheManager createCacheManager(Plugin owner, String cacheName, String myType) {
		return new LocalResourceFileCacheManager(owner, cacheName, myType);
	}

}

